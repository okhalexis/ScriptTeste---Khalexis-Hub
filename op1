----------------------------------------------------
-- AUTO FARM BRAINROT - LEVITANDO + NO CLIP AUTO
-- VERSÃO: 2.0 (ActiveTsunamis Full Scan + X-Distance)
----------------------------------------------------

local AutoFarmSection = Tabs.Farm:Section({
    Title  = "Auto Farm Brainrot",
    Icon   = "cpu",
    Box    = true,
    Opened = true,
})

----------------------------------------------------
-- CONFIGURAÇÕES E TABELAS DE DADOS
----------------------------------------------------

-- POSIÇÕES EXATAS DOS GAPS (Z = -14.0)
-- Coordenadas onde o player deve parar para estar seguro
local GapPositions = {
    { Index = 1,  Name = "Common",    X = 199.9,  Y = -2.7, Z = -14.0 },
    { Index = 2,  Name = "Uncommon",  X = 283.3,  Y = -2.7, Z = -14.0 },
    { Index = 3,  Name = "Rare",      X = 397.2,  Y = -2.7, Z = -14.0 },
    { Index = 4,  Name = "Epic",      X = 542.4,  Y = -2.7, Z = -14.0 },
    { Index = 5,  Name = "Legendary", X = 757.4,  Y = -2.7, Z = -14.0 },
    { Index = 6,  Name = "Mythical",  X = 1072.3, Y = -2.7, Z = -14.0 },
    { Index = 7,  Name = "Cosmic",    X = 1549.3, Y = -2.7, Z = -14.0 },
    { Index = 8,  Name = "Secret",    X = 2252.6, Y = -2.7, Z = -14.0 },
    { Index = 9,  Name = "Final",     X = 2599.1, Y = -2.7, Z = -14.0 },
}

-- LIMIAR DE DISTÂNCIA (ΔX) POR GAP
-- A onda mais próxima precisa estar PELO MENOS a essa distância em X para o player avançar
local GAP_SAFE_DELTAX = {
    [1] = 400,
    [2] = 500,
    [3] = 750,
    [4] = 1200,
    [5] = 1450,
    [6] = 2200,
    [7] = 2500,
    [8] = 2800,
    [9] = 2900,
}

-- ESTADO GLOBAL DO SISTEMA
local AutoGapState = {
    Enabled = false,
    TargetGapIndex = nil,
    CurrentGapIndex = 1,
    IsFlying = false,
    AutoFlyVelocity = nil,
    AutoFlyGyro = nil,
}

local AUTO_FLY_SPEED   = 220
local ARRIVAL_DISTANCE = 2
local CHECK_INTERVAL   = 0.03 -- 33 FPS para cálculos de física/distância

----------------------------------------------------
-- SISTEMA DE DETECÇÃO DE ONDAS (WAVE DETECTOR)
-- Analisa workspace.ActiveTsunamis em profundidade
----------------------------------------------------
local WaveDetector = {}

-- Obtém a pasta raiz das tsunamis ativas
local function getActiveTsunamisFolder()
    local folder = workspace:FindFirstChild("ActiveTsunamis")
    if folder then
        return folder
    end
    return nil
end

-- Função principal de detecção:
-- Varre TODAS as waves dentro da pasta e TODOS os seus descendentes.
-- Retorna a menor distância Delta X encontrada e a parte correspondente.
local function getNearestWaveDeltaX(playerPosX)
    local folder = getActiveTsunamisFolder()
    if not folder then 
        return nil, nil 
    end

    local nearestDeltaX = nil
    local nearestPart = nil

    -- 1. Itera sobre cada modelo de onda (RadioactiveWave, WackyWave, etc.)
    local waves = folder:GetChildren()
    
    for _, waveRoot in ipairs(waves) do
        -- 2. Varre todas as ramificações (GetDescendants) para encontrar a frente da onda
        -- Isso garante que pegamos a parte visual ou física que está mais avançada no mapa
        local descendants = waveRoot:GetDescendants()
        
        for _, descendant in ipairs(descendants) do
            if descendant:IsA("BasePart") then
                local waveX = descendant.Position.X
                local deltaX = waveX - playerPosX

                -- Consideramos apenas objetos que estão à frente do player (X positivo)
                if deltaX > 0 then
                    if not nearestDeltaX or deltaX < nearestDeltaX then
                        nearestDeltaX = deltaX
                        nearestPart = descendant
                    end
                end
            end
        end
    end

    return nearestDeltaX, nearestPart
end

-- Verifica se é seguro mover para o Gap especificado
-- isSafe  = true (pode andar), false (deve parar)
function WaveDetector.IsSafeForGap(gapIndex)
    local hrp = getHumanoidRootPart() -- Função externa esperada no seu ambiente
    if not hrp then
        return true, nil, nil
    end

    local threshold = GAP_SAFE_DELTAX[gapIndex]
    if not threshold then
        return true, nil, nil
    end

    local playerX = hrp.Position.X
    local deltaX, part = getNearestWaveDeltaX(playerX)

    -- Se não houver nenhuma wave no workspace, o caminho está livre
    if not deltaX then
        return true, nil, nil
    end

    -- Compara a distância da wave com o limiar configurado para este gap
    local isSafe = (deltaX >= threshold)
    
    return isSafe, deltaX, part
end

----------------------------------------------------
-- SISTEMA DE LEVITAÇÃO E MOVIMENTAÇÃO (AUTO FLY)
----------------------------------------------------
local AutoFly = {}

function AutoFly.Start()
    if AutoGapState.IsFlying then return true end

    local hrp = getHumanoidRootPart()
    local hum = getHumanoid()
    if not hrp or not hum then return false end

    AutoGapState.IsFlying = true
    hum.PlatformStand = true

    -- Criar BodyVelocity para controle total de movimento linear
    local bv = Instance.new("BodyVelocity")
    bv.Name = "AutoFarmVelocity"
    bv.MaxForce = Vector3.new(1e6, 1e6, 1e6)
    bv.Velocity = Vector3.zero
    bv.Parent = hrp
    AutoGapState.AutoFlyVelocity = bv

    -- Criar BodyGyro para manter o personagem ereto e olhando pro alvo
    local bg = Instance.new("BodyGyro")
    bg.Name = "AutoFarmGyro"
    bg.MaxTorque = Vector3.new(1e6, 1e6, 1e6)
    bg.P = 9e4
    bg.CFrame = hrp.CFrame
    bg.Parent = hrp
    AutoGapState.AutoFlyGyro = bg

    warn("[Wave System] Levitation Initialized at speed " .. tostring(AUTO_FLY_SPEED))
    return true
end

function AutoFly.Stop()
    if not AutoGapState.IsFlying then return end

    AutoGapState.IsFlying = false

    local hum = getHumanoid()
    if hum then 
        hum.PlatformStand = false 
    end

    if AutoGapState.AutoFlyVelocity then
        AutoGapState.AutoFlyVelocity:Destroy()
        AutoGapState.AutoFlyVelocity = nil
    end

    if AutoGapState.AutoFlyGyro then
        AutoGapState.AutoFlyGyro:Destroy()
        AutoGapState.AutoFlyGyro = nil
    end

    warn("[Wave System] Levitation Disabled")
end

function AutoFly.FlyToPosition(targetPos)
    local hrp = getHumanoidRootPart()
    if not hrp then return false end

    local currentPos = hrp.Position
    local offset = (targetPos - currentPos)
    
    -- Se a distância for insignificante, para o movimento
    if offset.Magnitude < 0.01 then
        if AutoGapState.AutoFlyVelocity then
            AutoGapState.AutoFlyVelocity.Velocity = Vector3.zero
        end
        return true
    end

    local direction = offset.Unit
    local velocityVector = direction * AUTO_FLY_SPEED

    -- Atualiza vetores de física
    if AutoGapState.AutoFlyVelocity then
        AutoGapState.AutoFlyVelocity.Velocity = velocityVector
    end

    if AutoGapState.AutoFlyGyro then
        AutoGapState.AutoFlyGyro.CFrame = CFrame.lookAt(currentPos, targetPos)
    end

    return true
end

function AutoFly.HasArrived(targetPos)
    local hrp = getHumanoidRootPart()
    if not hrp then return false end
    
    local distance = (hrp.Position - targetPos).Magnitude
    return distance <= ARRIVAL_DISTANCE
end

function AutoFly.PauseInPlace()
    if AutoGapState.AutoFlyVelocity then
        AutoGapState.AutoFlyVelocity.Velocity = Vector3.zero
    end
end

-- Teleporta para a posição exata e limpa a inércia ao chegar num gap
local function finishAtPosition(targetPos)
    local hrp = getHumanoidRootPart()
    local hum = getHumanoid()
    if not hrp then return end

    if AutoGapState.AutoFlyVelocity then
        AutoGapState.AutoFlyVelocity:Destroy()
        AutoGapState.AutoFlyVelocity = nil
    end
    if AutoGapState.AutoFlyGyro then
        AutoGapState.AutoFlyGyro:Destroy()
        AutoGapState.AutoFlyGyro = nil
    end
    
    AutoGapState.IsFlying = false

    if hum then
        hum.PlatformStand = false
    end

    -- Ajuste final de coordenadas
    hrp.CFrame = CFrame.new(targetPos)
    hrp.AssemblyLinearVelocity = Vector3.zero
    hrp.AssemblyAngularVelocity = Vector3.zero
end

----------------------------------------------------
-- LOOP PRINCIPAL DE EXECUÇÃO (BRAINROT LOGIC)
----------------------------------------------------
local autoFarmCoroutine = nil

local function getGapByIndex(idx)
    for _, gap in ipairs(GapPositions) do
        if gap.Index == idx then
            return gap
        end
    end
    return nil
end

local function autoFarmLoop()
    print("[SYSTEM] Auto Farm Loop Started")

    -- Ativa NoClip via Flags Globais (esperado no seu script)
    PlayerFlags.NoClipEnabled = true
    
    if not AutoFly.Start() then
        warn("[ERROR] Could not start Fly system")
        PlayerFlags.NoClipEnabled = false
        if disableFullNoClip then disableFullNoClip() end
        return
    end

    -- Sempre começa do Gap 1
    AutoGapState.CurrentGapIndex = 1

    while AutoGapState.Enabled do
        local hrp = getHumanoidRootPart()
        if not hrp then
            task.wait(0.5)
            continue
        end

        -- Verifica se já passou do objetivo final selecionado pelo usuário
        if AutoGapState.CurrentGapIndex > AutoGapState.TargetGapIndex then
            print("[SUCCESS] Final Gap Reached. Stopping.")

            PlayerFlags.NoClipEnabled = false
            if disableFullNoClip then disableFullNoClip() end

            WindUI:Notify({
                Title   = "Auto Farm",
                Content = "Alvo alcançado com sucesso! Mantendo posição.",
                Duration= 5,
                Icon    = "check-circle",
            })

            AutoGapState.Enabled = false
            break
        end

        -- Obtém dados do gap que estamos tentando alcançar agora
        local currentGap = getGapByIndex(AutoGapState.CurrentGapIndex)
        if not currentGap then
            warn("[ERROR] Gap data missing for index: " .. tostring(AutoGapState.CurrentGapIndex))
            task.wait(0.5)
            continue
        end

        local targetPos = Vector3.new(currentGap.X, currentGap.Y, currentGap.Z)

        -- ANALISADOR DE ONDAS EM TEMPO REAL
        -- Varre ActiveTsunamis a cada iteração
        local isSafe, deltaX, wavePart = WaveDetector.IsSafeForGap(AutoGapState.CurrentGapIndex)

        if not isSafe then
            -- Se não for seguro, fica parado levitando no lugar atual
            AutoFly.PauseInPlace()

            print(string.format(
                "[WAITING] Wave detected! DeltaX: %.1f | Threshold: %d | Gap: %d (%s) | Part: %s",
                deltaX or -1,
                GAP_SAFE_DELTAX[AutoGapState.CurrentGapIndex] or 0,
                AutoGapState.CurrentGapIndex,
                currentGap.Name,
                wavePart and wavePart.Name or "None"
            ))

            task.wait(CHECK_INTERVAL)
        else
            -- Se estiver seguro, voa em direção ao gap
            if AutoFly.HasArrived(targetPos) then
                -- Chegou no Gap! Para, limpa física e notifica
                finishAtPosition(targetPos)

                print(string.format(
                    "[PROGRESS] Arrived at Gap %d (%s). Moving to next...",
                    AutoGapState.CurrentGapIndex, currentGap.Name
                ))

                WindUI:Notify({
                    Title   = "Auto Farm",
                    Content = string.format("Chegou no %s (Gap %d)", currentGap.Name, AutoGapState.CurrentGapIndex),
                    Duration= 2,
                    Icon    = "map-pin",
                })

                -- Incrementa para o próximo gap e reinicia o motor de voo
                AutoGapState.CurrentGapIndex = AutoGapState.CurrentGapIndex + 1
                
                if AutoGapState.CurrentGapIndex <= AutoGapState.TargetGapIndex then
                    task.wait(0.2)
                    AutoFly.Start()
                end
            else
                -- Em trânsito...
                AutoFly.FlyToPosition(targetPos)
                task.wait(CHECK_INTERVAL)
            end
        end
    end

    -- Cleanup final ao desligar a toggle
    AutoFly.Stop()
    PlayerFlags.NoClipEnabled = false
    if disableFullNoClip then disableFullNoClip() end
    print("[SYSTEM] Auto Farm Loop Terminated")
end

----------------------------------------------------
-- INTERFACE DE USUÁRIO (CONTROLES)
----------------------------------------------------

-- Gera lista de nomes para o Dropdown
local function getAreaNames()
    local names = {}
    for _, gap in ipairs(GapPositions) do
        table.insert(names, gap.Name)
    end
    return names
end

-- Seletor de Destino
AutoFarmSection:Dropdown({
    Title  = "Select Target Area",
    Desc   = "Escolha até qual Gap o robô deve avançar",
    Icon   = "map-pin",
    Values = getAreaNames(),
    Value  = nil,
    Callback = function(value)
        for _, gap in ipairs(GapPositions) do
            if gap.Name == value then
                AutoGapState.TargetGapIndex = gap.Index
                
                print("[UI] Target set to: " .. gap.Name .. " (Index " .. tostring(gap.Index) .. ")")

                WindUI:Notify({
                    Title   = "Auto Farm",
                    Content = string.format("Objetivo definido: %s", value),
                    Duration= 3,
                    Icon    = "target",
                })
                break
            end
        end
    end
})

-- Interruptor de ativação
AutoFarmSection:Toggle({
    Title = "Start Auto Farm",
    Desc  = "Inicia a sequência do Gap 1 ao Alvo (Lógica X-Wave)",
    Icon  = "play",
    Value = false,
    Callback = function(state)
        AutoGapState.Enabled = state

        if state then
            -- Verificação de segurança antes de começar
            if not AutoGapState.TargetGapIndex then
                WindUI:Notify({
                    Title   = "Erro",
                    Content = "Selecione uma área de destino primeiro!",
                    Duration= 4,
                    Icon    = "alert-triangle",
                })
                AutoGapState.Enabled = false
                return
            end

            WindUI:Notify({
                Title   = "Auto Farm",
                Content = "Iniciando farm... Analisando ActiveTsunamis.",
                Duration= 4,
                Icon    = "rocket",
            })

            -- Inicia a Thread principal
            if autoFarmCoroutine then
                task.cancel(autoFarmCoroutine)
            end
            autoFarmCoroutine = task.spawn(autoFarmLoop)
        else
            -- Desligamento
            if autoFarmCoroutine then
                task.cancel(autoFarmCoroutine)
                autoFarmCoroutine = nil
            end

            AutoFly.Stop()
            PlayerFlags.NoClipEnabled = false
            if disableFullNoClip then disableFullNoClip() end

            WindUI:Notify({
                Title   = "Auto Farm",
                Content = "Farm interrompido pelo usuário.",
                Duration= 3,
                Icon    = "stop-circle",
            })
        end
    end
})

----------------------------------------------------
-- FIM DO SCRIPT
----------------------------------------------------
